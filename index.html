<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Ride the Bus Multiplayer1</title>
  <style>
    body {
      margin: 0;
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background: linear-gradient(to right, #0f2027, #203a43, #2c5364);
      color: #fff;
      display: flex;
      flex-direction: column;
      align-items: center;
      min-height: 100vh;
      padding-bottom: 3rem;
      overflow: auto;
    }
    .lobby {
      background: rgba(255, 255, 255, 0.1);
      padding: 2rem;
      border-radius: 20px;
      box-shadow: 0 10px 30px rgba(0, 0, 0, 0.6);
      text-align: center;
      max-width: 400px;
      margin-bottom: 2rem;
    }
    .lobby input {
      padding: 0.75rem;
      margin: 0.5rem 0;
      border-radius: 10px;
      border: none;
      width: 100%;
      font-size: 1rem;
    }
    .lobby button {
      padding: 0.75rem;
      border-radius: 10px;
      background: #ff4b2b;
      color: white;
      border: none;
      font-size: 1rem;
      width: 100%;
      cursor: pointer;
    }
    .lobby button:hover {
      background: #ff6a4b;
    }
    .lobby-list {
      margin-top: 1rem;
      background: rgba(255, 255, 255, 0.1);
      padding: 1rem;
      border-radius: 10px;
      max-height: 200px;
      overflow-y: auto;
    }
.player-box.eliminated {
  opacity: 0.4;
  font-style: italic;
}
    .hidden { display: none; }
    .player-stats { display: flex; flex-wrap: wrap; gap: 1rem; margin-top: 1rem; }
    .player-box { background: #ffffff22; padding: 1rem; border-radius: 10px; text-align: center; min-width: 150px; }
    .player-box.active { border: 2px solid gold; }
    .card-area { display: flex; flex-wrap: wrap; justify-content: center; gap: 1rem; margin: 1rem 0; }
    .card { width: 100px; height: 150px; border-radius: 10px; background: white; display: flex; align-items: center; justify-content: center; font-size: 1.5rem; font-weight: bold; box-shadow: 0 4px 8px rgba(0,0,0,0.4); }
    .card.red { color: red; }
    .card.blue {color: #003bdf;}

    .card.black { color: black; }
    .controls, .betting, .guesses { display: flex; flex-wrap: wrap; justify-content: center; gap: 0.5rem; margin-top: 1rem; }
    .controls button, .guesses button { padding: 0.8rem 1.5rem; font-size: 1.1rem; border: none; border-radius: 5px; background: #ff4b2b; color: white; cursor: pointer; }
    .controls button:hover, .guesses button:hover { background: #ff6a4b; }
    .status { font-size: 1.2rem; margin-top: 1rem; }
    input[type=number], select { padding: 0.5rem; border-radius: 5px; border: none; width: 100px; }
  .shop-item {
    background: rgba(255, 255, 255, 0.08);
    border: 2px solid rgba(255, 255, 255, 0.15);
    border-radius: 12px;
    padding: 0.75rem;
    margin: 0.5rem;
    flex: 1 1 150px; /* previously 250px */
    max-width: 180px; /* constrain to prevent huge width */
    min-width: 120px;
    text-align: center;
    box-shadow: 0 4px 10px rgba(0, 0, 0, 0.3);
    transition: transform 0.2s ease;
    word-wrap: break-word;
  }

  .shop-item:hover {
    transform: scale(1.03);
  }

  .shop-item button {
    background-color: #ff4b2b;
    border: none;
    padding: 0.5rem 1rem;
    color: white;
    border-radius: 6px;
    cursor: pointer;
    margin-top: 0.5rem;
  }

  .shop-item button:hover {
    background-color: #ff6a4b;
  }

  .glowing-red {
    box-shadow: 0 0 12px 4px red;
  }

  .glowing-gold {
    box-shadow: 0 0 12px 4px gold;
  }
  .glowing-orange {
    box-shadow: 0 0 12px 4px rgb(212, 115, 3);
  }

  #betModifiers,
  #cardUpgradeArea {
    display: flex;
    flex-wrap: wrap;
    justify-content: center;
    gap: 1rem;
  }

  #playerTokens {
    font-weight: bold;
    font-size: 1.1rem;
    margin-bottom: 0.5rem;
  }

  </style>

</head>
<body>
  <h1>Ride the Bus ðŸšŒ</h1>
  <!-- My Deck button -->
  <div style="position: absolute; top: 1rem; right: 1rem; z-index:1000;">
    <button id="viewDeckBtn">My Deck</button>
  </div>

  <!-- Deck modal (hidden by default) -->
  <div id="deckModal" class="hidden" 
        style="position: fixed; top:0; left:0; width:100%; height:100%; 
              background: rgba(0,0,0,0.8); color:#fff; overflow:auto; padding:2rem; z-index:1001;">
  
    <button id="closeDeckBtn" 
      style="position:fixed; top:1rem; right:1rem; font-size:1.2rem; z-index:1002;">
      âœ• Close
    </button>
    <h2>My Deck & Upgrades</h2>
    <div id="deckContent" style="margin-top:1rem;"></div>
  </div>

  <div class="lobby" id="lobby">
    <h2>Join or Create a Game</h2>
    <input type="text" id="playerName" placeholder="Your Name" />
    <input type="text" id="lobbyCode" placeholder="Lobby Code (6 chars)" maxlength="6" />
    <h1></h1>
    <button id="joinGameBtn">Join Game</button>
    <h3></h3>
    <button id="createGameBtn">Create Game</button>
    <div id="lobbyPlayers" class="lobby-list hidden"></div>
    <button id="startGameBtn" class="hidden" onclick="startGame()">Start Game</button>
  </div>

  <div id="gameUI" class="hidden">
    <div class="player-stats" id="playerStats"></div>
    <div class="betting">
      <label for="betAmount">Bet Amount: </label>
      <input type="number" id="betAmount" value="10" min="1" />
      <button id="startTurnBtn">Start Turn</button>

    </div>
    
      
    <div class="guesses" id="guessButtons"></div>
    <div class="card-area" id="cardArea"></div>
    <div class="status" id="status"></div>
    <div id="timerBarContainer" style="width: 100%; max-width: 400px; height: 20px; background: rgba(255,255,255,0.1); border-radius: 10px; overflow: hidden; margin-top: 10px;">
        <div id="timerBar" style="width: 100%; height: 100%; background: gold; transition: width 1s linear;"></div>
    </div>
    <div id="multiplierList" style="margin-top: 20px; padding: 1rem; background: rgba(255, 255, 255, 0.1); border-radius: 10px;">
      <h3>Multiplier Bonuses</h3>
      <ul id="multiplierBonuses">
        <!-- Populated dynamically -->
      </ul>
    </div>
    <div id="shopSection" style="margin-top: 20px; background: rgba(255,255,255,0.1); padding: 1rem; border-radius: 10px;" class="hidden">
        <h3>ðŸ›’ Shop</h3>
        <div id="playerTokens">Tokens: 0</div>
        <div id="betModifiers" style="margin-top: 10px;"></div>
        <div id="cardUpgradeArea" style="margin-top: 10px;"></div>
      </div>
      <div id="playerUpgrades" style="width: 100%; margin-top: 2rem; padding: 1rem; background: rgba(255,255,255,0.05); color: #ccc; font-size: 0.9rem; border-top: 1px solid rgba(255,255,255,0.2);">
        <!-- Populated dynamically -->
      </div>
  </div>
<audio id="turnSound" src="https://actions.google.com/sounds/v1/cartoon/wood_plank_flicks.ogg" preload="auto"></audio>

<script type="module">
    import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.0/firebase-app.js";
    import { getDatabase, ref, set, update, onValue, get, child, push, onChildAdded } from "https://www.gstatic.com/firebasejs/11.6.0/firebase-database.js";
  const firebaseConfig = {
    apiKey: "AIzaSyD5Zu_Qsv3reVuB6PrombL954zSKHWPewY",
    authDomain: "ride-the-bus-d9f3f.firebaseapp.com",
    projectId: "ride-the-bus-d9f3f",
    storageBucket: "ride-the-bus-d9f3f.firebasestorage.app",
    messagingSenderId: "1213292677",
    appId: "1:1213292677:web:123df0546c297f03fb49ec",
    measurementId: "G-X9VK7R0RQE"
  };

  const app = initializeApp(firebaseConfig);
  const db = getDatabase(app);
  // Multiplier bonuses per stage (modifiable later)
  const multipliers = {
    1: 2,
    2: 3,
    3: 4,
    4: 20,
    5: 500
  };

  async function displayMultipliers() {
  const list = document.getElementById("multiplierBonuses");
  if (!list || !playerRef) return;

  const snap = await get(playerRef);
  const player = snap.val();
  const mults = player?.multipliers || {};

  list.innerHTML = Object.entries(mults).map(([stage, mult]) =>
    `<li>Stage ${stage}: ${mult}x</li>`
  ).join('');
}


// Ensure createLobby is hooked up after everything is defined
window.addEventListener("DOMContentLoaded", () => {
  const createGameBtn = document.getElementById("createGameBtn");
  const joinGameBtn = document.getElementById("joinGameBtn");
  const startGameBtn = document.getElementById("startGameBtn");
  const startTurnBtn = document.getElementById("startTurnBtn");
  const resetGameBtn = document.querySelector(".controls button");

  if (createGameBtn) createGameBtn.addEventListener("click", () => {
    const generatedCode = generateLobbyCode();
    document.getElementById('lobbyCode').value = generatedCode;
    isHost = true;
    joinLobby();
  });

  if (joinGameBtn) joinGameBtn.addEventListener("click", () => {
    isHost = false;
    joinLobby();
  });
  const viewBtn  = document.getElementById('viewDeckBtn');
  const closeBtn = document.getElementById('closeDeckBtn');
  const modal    = document.getElementById('deckModal');

  if (!viewBtn)  return console.warn("â™ ï¸ viewDeckBtn not found");
  if (!closeBtn) return console.warn("â™ ï¸ closeDeckBtn not found");
  if (!modal)    return console.warn("â™ ï¸ deckModal not found");

  viewBtn.addEventListener('click', showDeck);
  closeBtn.addEventListener('click', () => {
    modal.classList.add('hidden');
  });

  if (startGameBtn) startGameBtn.addEventListener("click", startGame);

  if (startTurnBtn) startTurnBtn.addEventListener("click", async () => {
    const stateSnapPre = await get(stateRef);
    const statePre = stateSnapPre.val();
    if (statePre.currentStage !== 0) {
      alert("You already started your turn.");
      return;
    }
    
    correctGuessCount = 0
    endTurnAlreadyCalled = false;
    clearCountdown(); // clear the pre-turn timer

    const stateSnap = await get(stateRef);
    const state = stateSnap.val();
    if (state.currentPlayer !== playerId) return alert("It's not your turn.");

    // Only declare playerSnap once
    const playerSnap = await get(playerRef);
    const bet = parseInt(document.getElementById('betAmount').value);
    // â”€â”€â”€ Snowâ€‘baller support â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    const prevBalance = playerSnap.val().balance;
    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    
    if (bet > playerSnap.val().balance || bet <= 0) return alert('Invalid bet amount.');
    
    const newBalance = playerSnap.val().balance - bet;
    
    const isAllIn = bet === playerSnap.val().balance;
    await update(playerRef, {
      balance: newBalance,
      isAllIn,
      lastBalanceBeforeBet: prevBalance    // â† store for Snowâ€‘baller
    });

    localPlayer.balance = newBalance;

    await update(stateRef, {
      currentPlayer: playerId,
      currentStage: 1,
      drawnCards: [],
      bet,
      status: `${localPlayer.name} - Stage 1: Red or Black?`
    });

    startCountdown(20, () => {
      endTurn("Ran out of time! You lose.", 0);
    });
    
  });

  if (resetGameBtn) resetGameBtn.addEventListener("click", resetGame);
});

    let lobbyCode, playerId, playerRef, stateRef, deckRef;
    let localPlayer = {};
    let isHost = false;
    let drawnCards = [];
    let lastKnownCurrentPlayer = null;
    let countdownInterval = null;
    let countdownTimeout = null;
    let maxBetsPerPlayer = 10;
    let correctGuessCount = 0;
    
    function generateLobbyCode() {
      const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';
      return Array.from({ length: 6 }, () => chars[Math.floor(Math.random() * chars.length)]).join('');
    }

    window.createLobby = () => {
      const generatedCode = generateLobbyCode();
      document.getElementById('lobbyCode').value = generatedCode;
      isHost = true;
      joinLobby();
    };
    
    let joiningInProgress = false;
    window.joinLobby = async () => {
      if (joiningInProgress) return; // prevent double joins
      joiningInProgress = true;

      if (playerId) {
        joiningInProgress = false;
        return alert('You have already joined this lobby.');
      }

      lobbyCode = document.getElementById('lobbyCode').value.trim().toUpperCase();
      const name = document.getElementById('playerName').value.trim();
      if (!name || lobbyCode.length !== 6) {
        joiningInProgress = false;
        return alert('Please enter a name and valid 6-char lobby code.');
      }

      const playersSnap = await get(ref(db, `games/${lobbyCode}/players`));
      const players = playersSnap.val() || {};

      const nameTaken = Object.values(players).some(p => p.name === name);
      if (nameTaken) {
        joiningInProgress = false;
        return alert('That name is already taken in this lobby.');
      }

      const alreadyJoined = Object.entries(players).some(([_, p]) => p.name === name && p.id === playerId);
      if (alreadyJoined) {
        joiningInProgress = false;
        return alert('You have already joined this lobby.');
      }

      playerId = `player_${Math.floor(Math.random() * 100000)}`;
      playerRef = ref(db, `games/${lobbyCode}/players/${playerId}`);
      stateRef = ref(db, `games/${lobbyCode}/state`);
      deckRef = ref(db, `games/${lobbyCode}/deck`);

      localPlayer = {
        name,
        balance: 100,
        score: 0,
        roundsWon: 0,
        betsMade: 0,
        eliminated: false,
        purchaseTokens: 0,
        cardUpgrades: [],
        multipliers: {
          1: 2,
          2: 3,
          3: 4,
          4: 20,
          5: 500
        }
      };

      await set(playerRef, localPlayer);

      const lobbyList = document.getElementById('lobbyPlayers');
      lobbyList.classList.remove('hidden');
      if (isHost) document.getElementById('startGameBtn').classList.remove('hidden');

      onValue(ref(db, `games/${lobbyCode}/players`), (snapshot) => {
        const playersRef = ref(db, `games/${lobbyCode}/players`);
        onValue(playersRef, (snapshot) => {
          const players = snapshot.val();
          if (!players) return;

          get(stateRef).then(stateSnap => {
            const state = stateSnap.val();
            const currentId = state?.currentPlayer;

            updatePlayerStats(Object.entries(players).map(([id, data]) => ({
              id,
              ...data,
              isCurrent: id === currentId
            })));
          });
        });
        const players = snapshot.val();
        if (!players) return;
        lobbyList.innerHTML = '<h3>Players in Lobby:</h3>' +
          Object.values(players).map(p => `<div>${p.name}</div>`).join('');

        get(stateRef).then(stateSnap => {
          const state = stateSnap.val();
          const currentId = state?.currentPlayer;
          updatePlayerStats(Object.entries(players).map(([id, data]) => ({
            id,
            ...data,
            isCurrent: id === currentId
          })));
        });
      });

      onValue(stateRef, async (snapshot) => {
        const state = snapshot.val();
        if (state) {
          if (state.gameStarted) {
            document.getElementById('lobby').classList.add('hidden');
            document.getElementById('gameUI').classList.remove('hidden');
          }
          if (state.maxBetsPerPlayer) {
            maxBetsPerPlayer = state.maxBetsPerPlayer;
          }

          updateGameDOM(state);

          const playersSnap = await get(ref(db, `games/${lobbyCode}/players`));
          const players = playersSnap.val();
          const currentId = state?.currentPlayer;

          updatePlayerStats(Object.entries(players).map(([id, data]) => ({
            id,
            ...data,
            isCurrent: id === currentId
          })));

          if (!window.playedToneIds) window.playedToneIds = new Set();

          (state.successTones || []).forEach(tone => {
            if (!window.playedToneIds.has(tone.id)) {
              window.playedToneIds.add(tone.id);
              correctGuessCount = tone.count;
              playSuccessTone();
            }
          });

          if (!window.playedFailToneIds) window.playedFailToneIds = new Set();
          (snapshot.val().failureTones || []).forEach(tone => {
            if (!window.playedFailToneIds.has(tone.id)) {
              window.playedFailToneIds.add(tone.id);
              playFailureTone();
            }
          });

          if (currentId !== lastKnownCurrentPlayer && currentId === playerId) {
            correctGuessCount = 0;
            const playerSnap = await get(playerRef);
            const playerData = playerSnap.val();

            const interestPercent = playerData.interestPercent || 0;
            if (interestPercent > 0) {
              const interest = Math.floor(playerData.balance * (interestPercent / 100));
              const newBalance = playerData.balance + interest;
              await update(playerRef, { balance: newBalance });
              localPlayer.balance = newBalance;
              alert(`ðŸ’° ${playerData.name}, you earned $${interest} in interest (${interestPercent}%)!`);
            }

            playTurnSound();
            startCountdown(20, () => {
              endTurn("Ran out of time before starting turn!", 0);
            });
          }
          lastKnownCurrentPlayer = currentId;

          if (state.currentStage === 0) {
            const playerSnap = await get(playerRef);
            const playerData = playerSnap.val();

            if (playerData.showShop && (playerData.purchaseTokens || 0) > 0) {
              showShopOptions(playerData.isRoundWinner, playerData);
              await update(playerRef, { showShop: false });
            }
          }
        }
      });

      joiningInProgress = false;
    };

  window.startGame = () => {
  const fullDeck = [];
  const suits = ['â™ ', 'â™¥', 'â™¦', 'â™£'];
  const values = ['2','3','4','5','6','7','8','9','10','J','Q','K','A'];
  for (const suit of suits) {
    for (const val of values) {
      fullDeck.push({ text: val + suit, suit, value: val === 'A' ? 14 : val === 'K' ? 13 : val === 'Q' ? 12 : val === 'J' ? 11 : parseInt(val) });
    }
  }
  fullDeck.sort(() => Math.random() - 0.5);
  set(deckRef, fullDeck);
  get(ref(db, `games/${lobbyCode}/players`)).then((snap) => {
  const players = snap.val();
  const playerCount = Object.keys(players).length;

  // Determine max bets
  if (playerCount >= 6) maxBetsPerPlayer = 3;
  else if (playerCount >= 3) maxBetsPerPlayer = 6;
  else if (playerCount >= 4) maxBetsPerPlayer = 5;
  else if (playerCount >= 5) maxBetsPerPlayer = 4;

  else maxBetsPerPlayer = 10;

  const firstPlayerId = Object.keys(players)[0];
  set(stateRef, {
    gameStarted: true,
    currentPlayer: firstPlayerId,
    currentStage: 0,
    drawnCards: [],
    status: `Waiting for ${players[firstPlayerId].name} to start their turn.`,
    maxBetsPerPlayer: maxBetsPerPlayer
  });
});

};

async function applyCardUpgradeBonus(card) {
  const snap = await get(playerRef);
  const playerData = snap.val();
  const match = (playerData.cardUpgrades || []).find(up => up.text === card.text);
  if (!match) return;

  if (match.effect === '+1 bet') {
    const roundBonus = playerData.roundBetBonus || 0;
    await update(playerRef, { roundBetBonus: roundBonus + 1 });
    console.log(`Upgrade applied for ${card.text}: +1 bet this round`);
  }

  if (match.effect === 'Gain 25% of bet') {
    const stateSnap = await get(stateRef);
    const state = stateSnap.val();
    const bet = state.bet || 0;
    const bonus = Math.floor(bet * 0.25);

    localPlayer.balance += bonus;
    await update(playerRef, {
      balance: localPlayer.balance
    });

    console.log(`Upgrade applied for ${card.text}: gained $${bonus}`);
  }
  
  if (match.effect === 'remove_card') {
    console.log(`Upgrade applied for ${card.text}: card removed from deck`);
    // No effect to apply at draw time, since card should be filtered from deck
  }

  // â”€â”€â”€ New: 10% of current balance on draw â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  if (match.effect === 'Gain 10% of Balance') {
    // fetch fresh balance
    const snap = await get(playerRef);
    const pdata = snap.val() || {};
    const bonus = Math.floor(pdata.balance * 0.10);

    localPlayer.balance += bonus;
    await update(playerRef, { balance: localPlayer.balance });
    console.log(`Upgrade applied for ${card.text}: gained $${bonus} (10% of balance)`);
  }
  // â”€â”€â”€ new: +3 boost on next Cashâ€‘Out â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  if (match.effect === '+3 Mult') {
    await update(playerRef, { bonusPlus3Active: true });
    console.log(`+3 Mult drawn: will apply +3 on next cash-out`);
  }
  // â”€â”€â”€ new: oneâ€time 1.25Ã— boost for any cashâ€‘out this round â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  if (match.effect === '1.25x Mult') {
    // mark that future CashÂ Outs this round get +25%
    await update(playerRef, { bonusMult1_25Active: true });
    console.log(`1.25x card drawn: next cash-out this bet will be boosted`);
  }
  // â”€â”€â”€ Kingpin support â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  if ((playerData.kingpinCount || 0) > 0 && card.value === 13) {
    const stage    = (await get(stateRef)).val().currentStage;
    const oldMults = playerData.multipliers || {};
    const base     = oldMults[stage] ?? multipliers[stage];
    const boosted  = base + playerData.kingpinCount;
    const newMults = { ...oldMults, [stage]: boosted };
    await update(playerRef, { multipliers: newMults });
    console.log(`Kingpin: +${playerData.kingpinCount} multiplier applied at Stage ${stage} for drawing ${card.text}`);
  }
}

function createCardDisplay(card, effect = null) {
  const el = document.createElement('div');
  // new: red for â™¥â™¦, blue for â˜¾â˜…, else black
  let colorClass;
  if (card.suit === 'â™¥' || card.suit === 'â™¦')      colorClass = 'red';
  else if (card.suit === 'â˜¾' || card.suit === 'â˜…') colorClass = 'blue';
  else                                             colorClass = 'black';
  el.className = `card ${colorClass}`;

  if (effect === '+1 bet') {
    el.style.boxShadow = '0 0 12px 4px limegreen'; // green glow
  } else if (effect === 'Gain 25% of bet') {
    el.style.boxShadow = '0 0 12px 4px gold'; // yellow
  } else if (effect === 'remove_card') {
    el.style.boxShadow = '0 0 12px 4px red'; // red glow
  } else if (effect === 'Gain 10% of Balance') {
    el.style.boxShadow = '0 0 12px 4px orange'; // orange glow for 10% balance
  } else if (effect === '+3 Mult') {
    el.style.boxShadow = '0 0 12px 4px cyan';
  } else if (effect === '1.25x Mult') {
    el.style.boxShadow = '0 0 12px 4px magenta';
  }

  el.textContent = card.text;
  return el;
}


async function drawUniqueCard(drawnCards = [], excludeSameValue = false) {
  // 1ï¸âƒ£ load the shared deck
  const deckSnap   = await get(deckRef);
  const globalDeck = deckSnap.val() || [];

  // 2ï¸âƒ£ load this playerâ€™s modifiers
  const playerSnap      = await get(playerRef);
  const data            = playerSnap.val() || {};
  const dupCounts     = data.duplicateCounts || {};
  const boostCount      = data.aceTwoBoostCount   || 0;
  const facelessCount   = data.facelessCount      || 0;
  const remove2to4Count = data.remove2to4Count    || 0;

  // 3ï¸âƒ£ build the inâ€‘memory pool
  const pool = [...globalDeck];

  // filter out remove_card upgrades here too
const removed = (data.cardUpgrades || [])
  .filter(u => u.effect === 'remove_card')
  .map(u => u.text);
for (const text of removed) {
  // remove all matching entries
  let idx;
  while ((idx = pool.findIndex(c => c.text === text)) !== -1) {
    pool.splice(idx, 1);
  }
}


// â”€â”€â”€ Duplicateâ€‘card stacking â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Object.entries(dupCounts).forEach(([text, count]) => {
  // find one instance in the pool (if it passed filters)
  const template = pool.find(c => c.text === text);
  if (!template) return;
  for (let i = 0; i < count; i++) {
    pool.push({ ...template, _isDup: true });
  }
});

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  // â”€â”€â”€ Blue suits â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  if (data.addBlueSuits) {
    const blueSuits = ['â˜¾','â˜…'];
    const values    = ['2','3','4','5','6','7','8','9','10','J','Q','K','A'];
    for (const suit of blueSuits) {
      for (const v of values) {
        const num = v==='A'?14:v==='K'?13:v==='Q'?12:v==='J'?11:parseInt(v,10);
        pool.push({ text: v + suit, suit, value: num, _isBlue: true });
      }
    }
  }

  // â”€â”€â”€ Ace & Two stacking â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  if (boostCount > 0) {
    let suits = ['â™ ','â™¥','â™¦','â™£'];
    if (data.addBlueSuits)        suits.push('â˜¾','â˜…');
    if (data.removeDiamondsClubs) suits = suits.filter(s => s!=='â™¦' && s!=='â™£');

    for (let i = 0; i < boostCount; i++) {
      for (const suit of suits) {
        pool.push({ text: 'A' + suit, suit, value: 14, _isBlue: true });
        pool.push({ text: '2' + suit, suit, value: 2,  _isBlue: true });
      }
    }
  }

  // 4ï¸âƒ£ randomâ€‘draw with duplicate/suit/value checks
  let card  = null;
  let tries = pool.length;
  while (tries-- && !card) {
    const idx     = Math.floor(Math.random() * pool.length);
    const attempt = pool.splice(idx, 1)[0];

    const dupCard   = drawnCards.some(c => c.text  === attempt.text);
    const dupValue  = excludeSameValue && drawnCards.some(c => c.value === attempt.value);
    const removeSuit = data.removeDiamondsClubs
                    && (attempt.suit === 'â™¦' || attempt.suit === 'â™£');
    const removeFace = facelessCount > 0
                    && (attempt.value === 11 || attempt.value === 12 || attempt.value === 13);
    const removeLow  = remove2to4Count > 0
                    && (attempt.value === 2  || attempt.value === 3  || attempt.value === 4);

    if (dupCard || dupValue || removeSuit || removeFace || removeLow) {
      continue;
    }

    card = attempt;
  }

  // 5ï¸âƒ£ if it came from the shared deck, remove it there
  if (card && !card._isBlue && !card._isDup) {
    const newGlobal = globalDeck.filter(c => c.text !== card.text);
    await set(deckRef, newGlobal);
  }

  return card;
}





async function handleGuess(guess, state) {
  const stage = state.currentStage;
  const bet   = state.bet;

  // Helper: emit a success tone
  async function emitSuccess() {
    correctGuessCount++;
    const toneId = Date.now();
    const snap   = await get(stateRef);
    const curr   = snap.val() || {};
    await update(stateRef, {
      successTones: [...(curr.successTones || []), { id: toneId, count: correctGuessCount }]
    });
  }

  // Helper: emit a failure tone
  async function emitFailure() {
    const toneId = Date.now();
    const snap   = await get(stateRef);
    const curr   = snap.val() || {};
    await update(stateRef, {
      failureTones: [...(curr.failureTones || []), { id: toneId }]
    });
  }

  // â”€â”€â”€ Stage 1 â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  if (stage === 1) {
    const card = await drawUniqueCard([], false);
    if (!card) return endTurn('Deck is empty. Round ending early.', 0);
    await applyCardUpgradeBonus(card);

    const isRed   = card.suit === 'â™¥' || card.suit === 'â™¦';
    const isBlack = card.suit === 'â™ ' || card.suit === 'â™£';
    const isBlue  = card.suit === 'â˜¾' || card.suit === 'â˜…';

    await update(stateRef, { drawnCards: [card] });

    if ((guess === 'Red'   && isRed) ||
        (guess === 'Black' && isBlack) ||
        (guess === 'Blue'  && isBlue)) {
      state.currentStage = 2;
      state.status       = 'Correct! Cash out 2Ã— or pick Higher/Lower';
      await update(stateRef, state);
      await emitSuccess();
    } else {
      await emitFailure();
      return endTurn('Wrong guess. You lose.', 0);
    }
    return;
  }

  // â”€â”€â”€ Stage 2 â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  if (stage === 2) {
    if (guess === 'Cash Out') {
      // fetch player data so pdata is defined
      const psnap = await get(playerRef);
      const pdata = psnap.val() || {};

      // remove first card then compute payout
      const deckSnap = await get(deckRef);
      let deck = deckSnap.val() || [];
      deck = deck.filter(c => c.text !== state.drawnCards[0].text);
      await set(deckRef, deck);
      state.drawnCards = [];
      await update(stateRef, state);

      // 1) Base multiplier from cardâ€‘upgraded array
      let multiplier = pdata.multipliers?.[1] || multipliers[1];
      // 2) Card modifier â€œburnâ€ effects (run before any betâ€‘mods)
      // â”€â”€â”€ oneâ€‘time +3 Mult burn â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      if (pdata.bonusPlus3Active) {
        multiplier += 3;
        await update(playerRef, { bonusPlus3Active: false });
        console.log('Applied +3 mult on Stage 2 cash-out');
      }
      //    e.g. oneâ€‘time 1.25Ã— boost
      if (pdata.bonusMult1_25Active) {
        multiplier = Math.round(multiplier * 1.25);
        await update(playerRef, { bonusMult1_25Active: false });
        console.log('Applied 1.25x mult on Stage 2 cash-out');
      }

      // (If you had any other â€œonceâ€‘perâ€‘drawâ€ flags, handle them hereâ€¦)
      
      // 3) Now apply your bet modifiers in order
      // Clutch King (if youâ€™ve passed halfway)
      if (
        pdata.clutchKingCount > 0 &&
        pdata.betsMade > maxBetsPerPlayer / 2
      ) {
        multiplier += pdata.clutchKingCount;
      }
      if (pdata.snowballer && pdata.lastBalanceBeforeBet) {
        multiplier = multiplier + (bet / pdata.lastBalanceBeforeBet);
      }
      if (pdata.allInBonus && pdata.isAllIn) {
        multiplier *= 3;
      }
      
      return endTurn(
        `Cashed out $${Math.floor(bet * multiplier)}`,
        Math.floor(bet * multiplier)
      );
    }

    const prevValue = state.drawnCards[0].value;
    const card2     = await drawUniqueCard(state.drawnCards, true);
    if (!card2) return endTurn('Deck is empty. Round ending early.', 0);

    await applyCardUpgradeBonus(card2);
    state.drawnCards.push(card2);

    const curr = card2.value;
    if ((guess === 'Higher' && curr > prevValue) ||
        (guess === 'Lower'  && curr < prevValue)) {
      state.currentStage = 3;
      state.status       = 'Correct! Cash out 3Ã— or pick In-Between/Outside';
      await update(stateRef, state);
      await emitSuccess();
    } else {
      await update(stateRef, { drawnCards: state.drawnCards });
      await emitFailure();
      return endTurn('Wrong guess. You lose.', 0);
    }
    return;
  }

  // â”€â”€â”€ Stage 3 â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  if (stage === 3) {
    if (guess === 'Cash Out') {
      // 1) Remove the first drawn card
      const deckSnap = await get(deckRef);
      let deck = deckSnap.val() || [];
      deck = deck.filter(c => c.text !== state.drawnCards[0].text);
      await set(deckRef, deck);

      // 2) Clear drawn cards and persist
      state.drawnCards = [];
      await update(stateRef, state);

      // 3) Base multiplier for StageÂ 3 cashâ€‘out (3Ã—)
      const psnap = await get(playerRef);
      const pdata = psnap.val() || {};
      let multiplier = pdata.multipliers?.[2] || multipliers[2];

      // 4) Burn â€œoneâ€‘offâ€ card modifiers first
      if (pdata.bonusPlus3Active) {
        multiplier += 3;
        await update(playerRef, { bonusPlus3Active: false });
      }
      if (pdata.bonusMult1_25Active) {
        multiplier = Math.round(multiplier * 1.25);
        await update(playerRef, { bonusMult1_25Active: false });
      }

      // 5) Now apply betâ€‘modifiers in order
      if (pdata.clutchKingCount > 0 && pdata.betsMade > maxBetsPerPlayer / 2) {
        multiplier += pdata.clutchKingCount;
      }
      if (pdata.snowballer && pdata.lastBalanceBeforeBet) {
        multiplier += bet / pdata.lastBalanceBeforeBet;
      }
      if (pdata.allInBonus && pdata.isAllIn) {
        multiplier *= 3;
      }

      // 6) Finish
      return endTurn(
        `Cashed out $${Math.floor(bet * multiplier)}`,
        Math.floor(bet * multiplier)
      );
    }

    const card3 = await drawUniqueCard(state.drawnCards, true);
    if (!card3) return endTurn('Deck is empty. Round ending early.', 0);

    await applyCardUpgradeBonus(card3);
    state.drawnCards.push(card3);

    const [v1, v2]   = [state.drawnCards[0].value, state.drawnCards[1].value];
    const inBetween  = card3.value > Math.min(v1, v2) && card3.value < Math.max(v1, v2);

    if ((guess === 'In-Between' && inBetween) ||
        (guess === 'Outside'    && !inBetween)) {
      state.currentStage = 4;
      state.status       = 'Correct! Cash out 4Ã— or pick Suit';
      await update(stateRef, state);
      await emitSuccess();
    } else {
      await update(stateRef, { drawnCards: state.drawnCards });
      await emitFailure();
      return endTurn('Wrong guess. You lose.', 0);
    }
    return;
  }

  // â”€â”€â”€ Stage 4 â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  if (stage === 4) {
    if (guess === 'Cash Out') {
      // 1) Remove the first drawn card
      const deckSnap = await get(deckRef);
      let deck = deckSnap.val() || [];
      deck = deck.filter(c => c.text !== state.drawnCards[0].text);
      await set(deckRef, deck);

      // 2) Clear drawn cards and persist
      state.drawnCards = [];
      await update(stateRef, state);

      // 3) Base multiplier for StageÂ 4 cashâ€‘out (4Ã—)
      const psnap = await get(playerRef);
      const pdata = psnap.val() || {};
      let multiplier = pdata.multipliers?.[3] || multipliers[3];

      // 4) Burn card modifiers
      if (pdata.bonusPlus3Active) {
        multiplier += 3;
        await update(playerRef, { bonusPlus3Active: false });
      }
      if (pdata.bonusMult1_25Active) {
        multiplier = Math.round(multiplier * 1.25);
        await update(playerRef, { bonusMult1_25Active: false });
      }

      // 5) Betâ€‘modifiers
      if (pdata.clutchKingCount > 0 && pdata.betsMade > maxBetsPerPlayer / 2) {
        multiplier += pdata.clutchKingCount;
      }
      if (pdata.snowballer && pdata.lastBalanceBeforeBet) {
        multiplier += bet / pdata.lastBalanceBeforeBet;
      }
      if (pdata.allInBonus && pdata.isAllIn) {
        multiplier *= 3;
      }

      // 6) Finish
      return endTurn(
        `Cashed out $${Math.floor(bet * multiplier)}`,
        Math.floor(bet * multiplier)
      );
    }


    const card4 = await drawUniqueCard(state.drawnCards, true);
    if (!card4) return endTurn('Deck is empty. Round ending early.', 0);

    await applyCardUpgradeBonus(card4);
    state.drawnCards.push(card4);

    if (guess === card4.suit) {
      state.currentStage = 5;
      state.status       = 'Final Stage! Guess the exact card value!';
      await update(stateRef, state);
      await emitSuccess();
    } else {
      await update(stateRef, { drawnCards: state.drawnCards });
      await emitFailure();
      return endTurn('Wrong suit. You lose.', 0);
    }
    return;
  }

  // â”€â”€â”€ Stage 5 â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  if (stage === 5) {
    if (guess === 'Cash Out') {
      // 1) Remove the first drawn card
      const deckSnap = await get(deckRef);
      let deck = deckSnap.val() || [];
      deck = deck.filter(c => c.text !== state.drawnCards[0].text);
      await set(deckRef, deck);

      // 2) Clear drawn cards and persist
      state.drawnCards = [];
      await update(stateRef, state);

      // 3) Base multiplier for StageÂ 5 cashâ€‘out (20Ã—)
      const psnap = await get(playerRef);
      const pdata = psnap.val() || {};
      let multiplier = pdata.multipliers?.[4] || multipliers[4];

      // 4) Burn card modifiers
      if (pdata.bonusPlus3Active) {
        multiplier += 3;
        await update(playerRef, { bonusPlus3Active: false });
      }
      if (pdata.bonusMult1_25Active) {
        multiplier = Math.round(multiplier * 1.25);
        await update(playerRef, { bonusMult1_25Active: false });
      }

      // 5) Betâ€‘modifiers
      if (pdata.clutchKingCount > 0 && pdata.betsMade > maxBetsPerPlayer / 2) {
        multiplier += pdata.clutchKingCount;
      }
      if (pdata.snowballer && pdata.lastBalanceBeforeBet) {
        multiplier += bet / pdata.lastBalanceBeforeBet;
      }
      if (pdata.allInBonus && pdata.isAllIn) {
        multiplier *= 3;
      }

      // 6) Finish
      return endTurn(
        `Cashed out $${Math.floor(bet * multiplier)}`,
        Math.floor(bet * multiplier)
      );
    }


    const card5 = await drawUniqueCard(state.drawnCards, true);
    if (!card5) return endTurn('Deck is empty. Round ending early.', 0);

    await applyCardUpgradeBonus(card5);
    state.drawnCards.push(card5);

    const guessVal =
      guess === 'J' ? 11 :
      guess === 'Q' ? 12 :
      guess === 'K' ? 13 :
      guess === 'A' ? 14 :
      parseInt(guess, 10);

    if (card5.value === guessVal) {
      await update(stateRef, { drawnCards: state.drawnCards });
      await emitSuccess();

      const psnap = await get(playerRef);
      const pdata = psnap.val() || {};
      let multiplier = pdata.snowballer && pdata.lastBalanceBeforeBet
        ? (pdata.multipliers?.[5] || multipliers[5] || 500) + (bet / pdata.lastBalanceBeforeBet)
        : (pdata.multipliers?.[5] || multipliers[5] || 500);
      if (pdata.allInBonus && pdata.isAllIn) multiplier *= 3;

      return endTurn(
        `Unbelievable! Exact match! You win $${bet * multiplier}`,
        bet * multiplier
      );
    } else {
      await update(stateRef, { drawnCards: state.drawnCards });
      await emitFailure();
      return endTurn(`Wrong! The card was ${card5.text}. You lose.`, 0);
    }
  }
}


let endTurnAlreadyCalled = false; // global scope

async function endTurn(message, payout) {
  if (endTurnAlreadyCalled) return;
  endTurnAlreadyCalled = true;

  // â³ Get the latest player data from Firebase
  const playerSnap = await get(playerRef);
  const playerData = playerSnap.val();
  const prevBets = playerData?.betsMade || 0;

  // ðŸ§® Clamp increment to maxBetsPerPlayer
  const permBonus  = playerData.betModifierBonus  || 0; // shop modifiers
  const roundBonus = playerData.roundBetBonus     || 0; // card upgrades
  const effectiveMax = maxBetsPerPlayer + permBonus + roundBonus;
  const newBets = Math.min(prevBets + 1, effectiveMax);
  correctGuessCount = 0;

  if (payout === 0 && stateRef) {
    const stateSnap = await get(stateRef);
    const state = stateSnap.val();
    const failedStage = state?.currentStage;

    if (failedStage && failedStage >= 1 && failedStage <= 5) {
      const shields = playerData.shields || {};
      const recoveryPercent = shields[failedStage];
      if (recoveryPercent) {
        const recovered = Math.floor(state.bet * (recoveryPercent / 100));
        localPlayer.balance += recovered;
        await update(playerRef, { balance: localPlayer.balance });
        console.log(`Shield activated: recovered $${recovered} from failed Stage ${failedStage}`);
      }
    }
  }
  // ðŸ¤‘ Update balance if payout > 0
  if (payout > 0) {
    localPlayer.balance += payout;
    await update(playerRef, { balance: localPlayer.balance });
  }

  // âœ… Only update betsMade if we're still below the max
  if (prevBets < effectiveMax) {
    localPlayer.betsMade = newBets;
    await update(playerRef, {
      betsMade: newBets,
      balance: localPlayer.balance
    });
  }

  // Reset All In flag
  await update(playerRef, { isAllIn: false });

  // ðŸ’€ Eliminate if balance drops to 0
  if (localPlayer.balance <= 0) {
    localPlayer.eliminated = true;
    await update(playerRef, { eliminated: true });
  }

  // ðŸ§¼ Clean up visuals:
  // Always stop the timerâ€¦
  clearCountdown();
  // â€¦but only clear the card display & buttons if it was a payout (i.e. a correct cashâ€‘out or win).
  if (payout > 0) {
    document.getElementById('cardArea').innerHTML = '';
    document.getElementById('guessButtons').innerHTML = '';
  }

  // ðŸ“ Update status
  await update(stateRef, {
    status: `${localPlayer.name}: ${message}`,
    currentStage: 0
  });

  // ðŸ‘¥ Refresh player UI
  const playersSnap = await get(ref(db, `games/${lobbyCode}/players`));
  const players = playersSnap.val();
  updatePlayerStats(Object.entries(players).map(([id, data]) => ({
    id,
    ...data,
    isCurrent: id === playerId
  })));
  // ðŸƒ Refill deck if it's empty
  const deckSnap = await get(deckRef);
  const currentDeck = deckSnap.val() || [];
  if (currentDeck.length === 0) {
    const fullDeck = [];
    const suits = ['â™ ', 'â™¥', 'â™¦', 'â™£'];
    const values = ['2','3','4','5','6','7','8','9','10','J','Q','K','A'];
    for (const suit of suits) {
      for (const val of values) {
        fullDeck.push({
          text: val + suit,
          suit,
          value: val === 'A' ? 14 : val === 'K' ? 13 : val === 'Q' ? 12 : val === 'J' ? 11 : parseInt(val)
        });
      }
    }
    fullDeck.sort(() => Math.random() - 0.5);
    await set(deckRef, fullDeck);
  }
  // ðŸ” Check if round is complete
  checkRoundCompletion();
}





async function updateGameDOM(state) {
  // 1) Update the status line
  document.getElementById('status').textContent = state.status || '';

  // 2) Fetch the *current* player's data (so everyone sees THEIR upgrades glowing)
  const currentPlayerId   = state.currentPlayer;
  const playerSnap        = await get(ref(db, `games/${lobbyCode}/players/${currentPlayerId}`));
  const currentPlayerData = playerSnap.val() || {};

  // 3) Redraw the card play area, using their cardUpgrades for the glow
  const cardArea = document.getElementById('cardArea');
  cardArea.innerHTML = '';
  (state.drawnCards || []).forEach(card => {
    // find if *they* bought an upgrade for this card
    const match = (currentPlayerData.cardUpgrades || []).find(up => up.text === card.text);
    // pass that effect into createCardDisplay
    const cardEl = createCardDisplay(card, match?.effect);
    cardArea.appendChild(cardEl);
  });

  // 4) Rebuild the guess buttons for *your* turn
  const guessArea = document.getElementById('guessButtons');
  guessArea.innerHTML = '';
  if (state.currentPlayer === playerId && state.currentStage > 0) {
    // we still need *your* own data for multipliers & flags
    const snap = await get(playerRef);
    const pdata = snap.val() || {};
    const bet   = state.bet || 0;
    const stage = state.currentStage;

    // build options
    let options = [];
    if (stage === 1) {
      options = ['Red','Black'];
      if (pdata.addBlueSuits) options.push('Blue');
    } else if (stage === 4) {
      const suits = ['â™ ','â™¥','â™¦','â™£'];
      if (pdata.addBlueSuits) suits.push('â˜¾','â˜…');
      options = ['Cash Out', ...suits];
    } else {
      options = getOptionsForStage(stage);
    }

    // render
    options.forEach(opt => {
      const btn = document.createElement('button');
      if (opt === 'Cash Out') {
        const baseKey  = stage - 1;
        const baseMult = pdata.multipliers?.[baseKey] ?? multipliers[baseKey];

        let actualMult = baseMult;

        // â”€â”€â”€ cardâ€‘burn modifiers â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        if (pdata.bonusPlus3Active) {
          actualMult += 3;
        }
        if (pdata.bonusMult1_25Active) {
          actualMult = Math.round(actualMult * 1.25);
        }

        // â”€â”€â”€ your existing betâ€‘modifiers â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        if (pdata.snowballer && pdata.lastBalanceBeforeBet) {
          actualMult += bet / pdata.lastBalanceBeforeBet;
        }
        if (pdata.allInBonus && pdata.isAllIn) {
          actualMult *= 3;
        }
        if (
          pdata.clutchKingCount > 0 &&
          pdata.betsMade > maxBetsPerPlayer / 2
        ) {
          actualMult += pdata.clutchKingCount;
        }

        btn.textContent = `Cash Out (${actualMult.toFixed(2)}x)`;
      } else {
        // show the guess option text for everything else
        btn.textContent = opt;
      }
      btn.onclick = () => {
        clearCountdown();
        handleGuess(opt, state);
      };
      guessArea.appendChild(btn);
    });

    startCountdown(20, () => endTurn("Ran out of time! You lose.", 0));
  }

  // 5) Finally, update the multiplier list
  displayMultipliers();
}




    function getOptionsForStage(stage) {
      if (stage === 1) return ['Red', 'Black'];
      if (stage === 2) return ['Cash Out', 'Higher', 'Lower'];
      if (stage === 3) return ['Cash Out', 'In-Between', 'Outside'];
      if (stage === 4) return ['Cash Out','â™ ', 'â™¥', 'â™¦', 'â™£'];
      if (stage === 5) return ['Cash Out', '2','3','4','5','6','7','8','9','10','J','Q','K','A'];
      return [];
    }


function updatePlayerStats(players) {
  const container = document.getElementById('playerStats');
  container.innerHTML = '';
  const upgradeSummary = [];
  const maxRounds = Math.max(...players.map(p => p.roundsWon || 0));
players.forEach((p) => {
  const isLeader = (p.roundsWon || 0) === maxRounds && maxRounds > 0;

    const box = document.createElement('div');
    box.className = 'player-box' + (p.isCurrent ? ' active' : '') + (p.eliminated ? ' eliminated' : '');
    const permBonus  = p.betModifierBonus  || 0;
    const roundBonus = p.roundBetBonus     || 0;
    box.innerHTML = `
    <strong>${p.name} ${isLeader ? 'ðŸ‘‘' : ''}</strong><br>
    Balance: $${p.balance}<br>
    Score: ${p.score}<br>
    Rounds Won: ${p.roundsWon}<br>
    Bets Made: ${p.betsMade || 0}/${maxBetsPerPlayer + permBonus + roundBonus}
    ${p.eliminated ? '<em>Eliminated</em>' : ''}
    `;
    container.appendChild(box);
    const shieldStages = Object.keys(p.shields || {}).join(', ') || 'None';
    const cardUps = (p.cardUpgrades || []).map(c => `${c.text} (${c.effect})`).join(', ') || 'None';

    upgradeSummary.push(`
      <strong>${p.name}</strong>: 
      Bet Modifiers: ${p.betModifierBonus || 0}, 
      Interest: ${p.interestPercent || 0}%, 
      Shields: ${shieldStages}, 
      Card Upgrades: ${cardUps}
    `);
  });
  const upgradesDiv = document.getElementById('playerUpgrades');
  if (upgradesDiv) {
    upgradesDiv.innerHTML = `<h3>Player Modifiers & Upgrades</h3>` + 
      players.map(p => {
        const history = p.modifierHistory || [];
        const listItems = history.map(item => `<li>${item}</li>`).join('');
        return `<strong>${p.name}</strong><ul style="margin-top: 0.25rem; margin-bottom: 1rem;">${listItems || '<li>None</li>'}</ul>`;
      }).join('');
  }
}


async function advanceToNextPlayer() {
  const playersSnap = await get(ref(db, `games/${lobbyCode}/players`));
  const players = playersSnap.val();
  if (!players) return;

  const ids = Object.keys(players);
  const stateSnap = await get(stateRef);
  const currentId = stateSnap.val()?.currentPlayer;
  const currentIndex = ids.indexOf(currentId);

  let nextPlayerId = null;

  for (let i = 1; i <= ids.length; i++) {
    const candidateIndex = (currentIndex + i) % ids.length;
    const candidateId = ids[candidateIndex];
    const staticPlayer = players[candidateId]; // from cache
    const playerSnap = await get(ref(db, `games/${lobbyCode}/players/${candidateId}`));
    const dynamicPlayer = playerSnap.val(); // fresh from Firebase
    const effectiveMax = maxBetsPerPlayer + (dynamicPlayer.betModifierBonus || 0) + (dynamicPlayer.roundBetBonus    || 0);
    if (dynamicPlayer && !dynamicPlayer.eliminated && dynamicPlayer.betsMade < effectiveMax) {
      nextPlayerId = candidateId;
      break;
    }
  }

  if (nextPlayerId) {
    await update(stateRef, { currentPlayer: nextPlayerId });

    // ðŸ”¥ Update the player stats UI right away with new current player
    updatePlayerStats(Object.entries(players).map(([id, data]) => ({
      id,
      ...data,
      isCurrent: id === nextPlayerId
    })));
  }
}


function playTurnSound() {
  const sound = document.getElementById('turnSound');
  if (sound) {
    sound.currentTime = 0;
    sound.play().catch(e => console.warn("Sound playback failed:", e));
  }
}

function startCountdown(seconds, onExpire) {
  clearCountdown();

  const bar = document.getElementById("timerBar");
  const container = document.getElementById("timerBarContainer");

  bar.style.width = "100%";
  container.style.display = "block";

  let timeLeft = seconds;
  const total = seconds;

  countdownInterval = setInterval(() => {
    timeLeft--;
    const percent = (timeLeft / total) * 100;
    bar.style.width = percent + "%";
  }, 1000);

  countdownTimeout = setTimeout(() => {
    clearCountdown();
    onExpire();
  }, seconds * 1000);
}

let lastCardOffered = null;

// Build the array of every card instance in *this* player's deck
function buildPlayerDeck(playerData) {
  const baseSuits = ['â™ ','â™¥','â™¦','â™£'];
  const values    = ['2','3','4','5','6','7','8','9','10','J','Q','K','A'];
  let deck = [];

  // 1) One of each base card
  for (const suit of baseSuits) {
    for (const v of values) {
      const num = v==='A'?14:v==='K'?13:v==='Q'?12:v==='J'?11:parseInt(v,10);
      deck.push({ text: v + suit, suit, value: num });
    }
  }

  // 2) Blue suits if owned
  if (playerData.addBlueSuits) {
    for (const suit of ['â˜¾','â˜…']) {
      for (const v of values) {
        const num = v==='A'?14:v==='K'?13:v==='Q'?12:v==='J'?11:parseInt(v,10);
        deck.push({ text: v + suit, suit, value: num });
      }
    }
  }

  // 3) Ace & Two boosts (one extra per purchase)
  const boostCount = playerData.aceTwoBoostCount || 0;
  if (boostCount > 0) {
    let suits = [...baseSuits];
    if (playerData.addBlueSuits)      suits.push('â˜¾','â˜…');
    if (playerData.removeDiamondsClubs)
      suits = suits.filter(s => s!=='â™¦' && s!=='â™£');
    for (let i = 0; i < boostCount; i++) {
      for (const s of suits) {
        deck.push({ text:'A'+s, suit:s, value:14 });
        deck.push({ text:'2'+s, suit:s, value:2  });
      }
    }
  }

  // 4) Removals: diamonds & clubs, faceless, remove2-4
  const facelessCount   = playerData.facelessCount   || 0;
  const remove2to4Count = playerData.remove2to4Count || 0;
  deck = deck.filter(c => {
    if (playerData.removeDiamondsClubs && (c.suit==='â™¦'||c.suit==='â™£')) return false;
    if (facelessCount   > 0 && [11,12,13].includes(c.value)) return false;
    if (remove2to4Count > 0 && [2,3,4].includes(c.value))      return false;
    return true;
  });

  // â”€â”€â”€ Remove any cards that the player has â€œremovedâ€ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  const removed = (playerData.cardUpgrades || [])
    .filter(u => u.effect === 'remove_card')
    .map(u => u.text);
  deck = deck.filter(c => !removed.includes(c.text));

  return deck;
}


async function showShopOptions(isWinner, playerData) {
  // 1) Reveal the shop UI and update tokens
  const shop = document.getElementById('shopSection');
  if (!shop) return;
  shop.classList.remove('hidden');
  document.getElementById('playerTokens').textContent = `Tokens: ${playerData.purchaseTokens || 0}`;

  // 2) Fetch the shared modifier list from state
  const stateSnap   = await get(stateRef);
  const state       = stateSnap.val() || {};
  const sharedNames = state.sharedBetModifiers || [];

  // 3) Determine how many mods to show (winners see all)
  const limit      = isWinner ? sharedNames.length : sharedNames.length - 1;
  const shownNames = sharedNames.slice(0, limit);

  // ðŸŽ¯ Logic map
  const betModifiersMap = {
    "Bonus Bets": {
      name: "Bonus Bets",
      desc: "+2 bets per round",
      apply: async () => {
        const snap = await get(playerRef);
        const data = snap.val();
        const currentBonus = data.betModifierBonus || 0;
        const currentTokens = data.purchaseTokens || 0;
        if (currentTokens <= 0) return alert("You don't have enough tokens.");

        // Apply the bonus
        await update(playerRef, {
          betModifierBonus: currentBonus + 2,
          purchaseTokens: currentTokens - 1
        });
        alert("You will now be able to make 2 more bets this round!");

        // Update history
        const history = data.modifierHistory || [];
        history.push("+2 bets per round");

        await update(playerRef, {
          modifierHistory: history
        });
      }
    },
    "Super Multiplier": {
      name: "Super Multiplier",
      desc: "Increase all win multipliers by 1.25x, -2 bets",
      apply: async () => {
        const snap = await get(playerRef);
        const data = snap.val();
        const tokens = data.purchaseTokens || 0;
        if (tokens <= 0) return alert("You don't have enough tokens.");
        const oldMultipliers = data.multipliers || { 1: 2, 2: 3, 3: 4, 4: 20, 5: 500 };
        const newMultipliers = {};
        for (const [stage, mult] of Object.entries(oldMultipliers)) {
          newMultipliers[stage] = Math.round(mult * 1.25);
        }
        const currentBonus = data.betModifierBonus || 0;
        await update(playerRef, {
          multipliers: newMultipliers,
          betModifierBonus: currentBonus - 2,
          purchaseTokens: tokens - 1
        });
        alert("Multipliers increased by 1.25x! You lose 2 bets.");

        const history = data.modifierHistory || [];
        history.push("Increase all win multipliers by 1.25x, -2 bets");

        await update(playerRef, {
          purchaseTokens: tokens - 1,
          modifierHistory: history
        });

      }
    },
    "All In Bonus": {
      name: "All In Bonus",
      desc: "Going all-in triples your multiplier for that bet",
      apply: async () => {
        const snap   = await get(playerRef);
        const data   = snap.val() || {};
        const tokens = data.purchaseTokens || 0;

        // â‘  only once
        if (data.allInBonus) {
          return alert("âš ï¸ You already have All In Bonus and cannot purchase it again.");
        }
        // â‘¡ token check
        if (tokens <= 0) {
          return alert("You don't have enough tokens.");
        }

        // â‘¢ record in history
        const history = data.modifierHistory || [];
        history.push("Going all-in triples your multiplier for that bet");

        // â‘£ apply
        await update(playerRef, {
          allInBonus:       true,
          purchaseTokens:   tokens - 1,
          modifierHistory:  history
        });

        // â‘¤ feedback
        alert("ðŸŽ‰ All In Bonus unlocked! If you go all-in, your multiplier will be tripled.");
        document.getElementById('playerTokens').textContent = `Tokens: ${tokens - 1}`;
      }
    },
    "Blue Suits & Boost": {
      name: "Blue Suits & Boost",
      desc: "Add two new suits (â˜¾ & â˜…) and multiply your win multipliers by 2x",
      apply: async () => {
        // 1ï¸âƒ£ fetch latest player data
        const snap = await get(playerRef);
        const data = snap.val() || {};

        // â€”â€”â€” if already owned, block and inform â€”â€”â€”
        if (data.addBlueSuits) {
          return alert("âš ï¸ You already have Blue Suits & Boost and cannot purchase it again.");
        }

        // 2ï¸âƒ£ token check
        const tokens = data.purchaseTokens || 0;
        if (tokens <= 0) return alert("You don't have enough tokens.");

        // 3ï¸âƒ£ deduct token & flag
        const newTokens = tokens - 1;
        await update(playerRef, {
          addBlueSuits: true,
          purchaseTokens: newTokens
        });
        // mirror in-memory
        localPlayer.addBlueSuits = true;
        localPlayer.purchaseTokens = newTokens;

        // 4ï¸âƒ£ record history
        const history = data.modifierHistory || [];
        history.push("Added Blue Suits & 2x multipliers");
        await update(playerRef, { modifierHistory: history });

        // 5ï¸âƒ£ bump up multipliers
        const oldMults = data.multipliers || {1:2,2:3,3:4,4:20,5:500};
        const newMults = {};
        for (const [stage, m] of Object.entries(oldMults)) {
          newMults[stage] = Math.round(m * 2);
        }
        await update(playerRef, { multipliers: newMults });


        alert("ðŸŽ‰ You've unlocked the Blue Suits and your multipliers are now 2x higher!");
        document.getElementById('playerTokens').textContent = `Tokens: ${newTokens}`;
      }
    },
    "Remove Diamonds & Clubs": {
      name: "Remove Diamonds & Clubs",
      desc: "Skip all â™¦ and â™£ when drawing cards",
      apply: async () => {
        const snap = await get(playerRef);
        const data = snap.val();
        const tokens = data.purchaseTokens || 0;
        if (tokens <= 0) return alert("You don't have enough tokens.");

        // Mark this player as â€œremovingâ€ those suits
        await update(playerRef, {
          removeDiamondsClubs: true,
          purchaseTokens: tokens - 1
        });

        // Record in history
        const history = data.modifierHistory || [];
        history.push("Remove all diamonds and clubs");
        await update(playerRef, { modifierHistory: history });

        alert("All â™¦ and â™£ will now be skipped in your draws!");
      }
    },
    "Remove 2-4": {
      name: "Remove 2-4",
      desc: "Skip all 2s, 3s & 4s in your draws (stackable)",
      apply: async () => {
        const snap   = await get(playerRef);
        const data   = snap.val() || {};
        const tokens = data.purchaseTokens || 0;
        if (tokens <= 0) return alert("You don't have enough tokens.");

        // bump the count
        const newCount = (data.remove2to4Count || 0) + 1;
        await update(playerRef, {
          remove2to4Count:   newCount,
          purchaseTokens:    tokens - 1,
          modifierHistory: [
            ...(data.modifierHistory || []),
            `Remove 2-4 x${newCount}`
          ]
        });

        alert(`ðŸš« Cards 2, 3 & 4 will now be removed from your draws (purchased ${newCount}x).`);
        document.getElementById('playerTokens').textContent = `Tokens: ${tokens - 1}`;
      }
    },
    "Snow-baller": {
      name: "Snow-baller",
      desc: "Win-multiplier = multiplier + (bet / balance) for your next bet",
      apply: async () => {
        const snap = await get(playerRef);
        const data = snap.val() || {};
        const tokens = data.purchaseTokens || 0;
        if (data.snowballer) return alert("âš ï¸ You already have Snow-baller.");
        if (tokens <= 0)       return alert("Not enough tokens.");

        // mark as owned
        await update(playerRef, {
          snowballer: true,
          purchaseTokens: tokens - 1
        });

        // record history
        const history = data.modifierHistory || [];
        history.push("Snow-baller: dynamic multiplier by % bet");
        await update(playerRef, { modifierHistory: history });

        alert("â„ï¸ Snow-baller unlocked! Your next bet's multiplier will be multiplier + (bet / balance).");
      }
    },
    "Ace & Two": {
      name: "Ace & Two",
      desc: "Add 1 Ace and 1 '2' for each suit you have per purchase",
      apply: async () => {
        const data   = (await get(playerRef)).val() || {};
        const tokens = data.purchaseTokens || 0;
        if (tokens <= 0) return alert("You don't have enough tokens.");

        const newCount = (data.aceTwoBoostCount || 0) + 1;
        await update(playerRef, {
          aceTwoBoostCount: newCount,
          purchaseTokens:   tokens - 1,
          modifierHistory: [
            ...(data.modifierHistory || []),
            `Ace & Two x${newCount}`
          ]
        });

        alert(`ðŸŽ‰ Ace & Two purchased! You now get +${newCount} Aces & 2s per suit.`);
        document.getElementById('playerTokens').textContent = `Tokens: ${tokens - 1}`;
      }
    },
    "Faceless": {
      name: "Faceless",
      desc: "Remove all J/Q/K from your draws (can stack purchases)",
      apply: async () => {
        const data   = (await get(playerRef)).val() || {};
        const tokens = data.purchaseTokens || 0;
        if (tokens <= 0) return alert("You don't have enough tokens.");

        const newCount = (data.facelessCount || 0) + 1;
        await update(playerRef, {
          facelessCount:   newCount,
          purchaseTokens:  tokens - 1,
          modifierHistory: [
            ...(data.modifierHistory || []),
            `Faceless x${newCount}`
          ]
        });

        alert(`ðŸ†“ Faceless purchased! J/Q/K will be removed from your draws.`);
        document.getElementById('playerTokens').textContent = `Tokens: ${tokens - 1}`;
      }
    },
    "Starting Balance Boost": {
      name: "Starting Balance Boost",
      desc: "Multiply your next round's starting balance by 1.5x",
      apply: async () => {
        const snap   = await get(playerRef);
        const data   = snap.val() || {};
        const tokens = data.purchaseTokens || 0;
        if (tokens <= 0) return alert("You don't have enough tokens.");

        // 1ï¸âƒ£ compute new multiplier
        const oldMult = data.startBalanceMultiplier || 1;
        const newMult = oldMult * 1.5;

        // 2ï¸âƒ£ save it, deduct token & record history
        await update(playerRef, {
          startBalanceMultiplier: newMult,
          purchaseTokens:         tokens - 1,
          modifierHistory: [
            ...(data.modifierHistory || []),
            `Starting Balance ${newMult.toFixed(2)}x`
          ]
        });

        // 3ï¸âƒ£ feedback
        alert(`ðŸ’° Your next rounds will start with ${newMult.toFixed(2)}x the base balance.`);
        document.getElementById('playerTokens').textContent = `Tokens: ${tokens - 1}`;
      }
    },
    "Humble Beginnings": {
      name: "Humble beginnings",
      desc: "Halve your next round's starting balance and increase all win multipliers by 1.25x",
      apply: async () => {
        const snap   = await get(playerRef);
        const data   = snap.val() || {};
        const tokens = data.purchaseTokens || 0;
        if (tokens <= 0) return alert("You don't have enough tokens.");

        // 1ï¸âƒ£ Compute new start balance multiplier (divide by 2 each purchase)
        const oldSBMult = data.startBalanceMultiplier || 1;
        const newSBMult = oldSBMult / 2;

        // 2ï¸âƒ£ Compute new stage multipliers (Ã—1.25 each purchase)
        const oldMults = data.multipliers || {1:2,2:3,3:4,4:20,5:500};
        const newMults = {};
        for (const [stage, m] of Object.entries(oldMults)) {
          newMults[stage] = Math.round(m * 1.25);
        }

        // 3ï¸âƒ£ Track how many times they've bought this
        const newCount = (data.humbleCount || 0) + 1;

        // 4ï¸âƒ£ Deduct token and record everything
        const newTokens = tokens - 1;
        const history   = data.modifierHistory || [];
        history.push(`Half starting balance, all multipliers 1.25x #${newCount}`);

        await update(playerRef, {
          humbleCount:            newCount,
          startBalanceMultiplier: newSBMult,
          multipliers:            newMults,
          purchaseTokens:         newTokens,
          modifierHistory:        history
        });

        alert(
          `Humble beginnings purchased (${newCount}x)!\n` +
          `â†’ Next round start balance: ${newSBMult.toFixed(2)}x base\n`
        );
        document.getElementById('playerTokens').textContent = `Tokens: ${newTokens}`;
      }
    },
    "Clutch King": {
      name: "Clutch King",
      desc: "Gain +1 multiplier on bets once you're past halfway through your max bets (stackable)",
      apply: async () => {
        const snap   = await get(playerRef);
        const data   = snap.val() || {};
        const tokens = data.purchaseTokens || 0;
        if (tokens <= 0) return alert("You don't have enough tokens.");

        // stack count
        const newCount = (data.clutchKingCount || 0) + 1;

        // record in history
        const history = data.modifierHistory || [];
        history.push(`Clutch King x${newCount}`);

        // persist
        await update(playerRef, {
          clutchKingCount:  newCount,
          purchaseTokens:   tokens - 1,
          modifierHistory:  history
        });

        alert(`ðŸ† Clutch King purchased! On late bets you now get +${newCount} to your multiplier.`);
        document.getElementById('playerTokens')
                .textContent = `Tokens: ${tokens - 1}`;
      }
    },
    "Kingpin": {
      name: "Kingpin",
      desc: "Whenever a King appears, increase your win multiplier by 1 (stackable)",
      apply: async () => {
        const snap   = await get(playerRef);
        const data   = snap.val() || {};
        const tokens = data.purchaseTokens || 0;
        if (tokens <= 0) return alert("You don't have enough tokens.");
        // stack one more Kingpin
        const newCount = (data.kingpinCount || 0) + 1;
        const history  = data.modifierHistory || [];
        history.push(`Kingpin x${newCount}`);
        await update(playerRef, {
          kingpinCount:      newCount,
          purchaseTokens:    tokens - 1,
          modifierHistory:   history
        });
        alert(`ðŸƒ Kingpin purchased! From now on, each King drawn gives you +1 this round's multiplier.`);
        document.getElementById('playerTokens').textContent = `Tokens: ${tokens - 1}`;
      }
    },

    "Bonus Interest": {
      name: "Bonus Interest",
      desc: "Earn +10% of your balance at the start of your turn",
      apply: async () => {
        const snap = await get(playerRef);
        const data = snap.val();
        const tokens = data.purchaseTokens || 0;
        if (tokens <= 0) return alert("You don't have enough tokens.");

        const currentInterest = data.interestPercent || 0;
        const newInterest = currentInterest + 10;

        await update(playerRef, {
          interestPercent: newInterest,
          purchaseTokens: tokens - 1
        });

        alert(`You will now earn +${newInterest}% interest at the start of each turn!`);

        const history = data.modifierHistory || [];
        history.push("+10% Bonus interest");

        await update(playerRef, {
          interestPercent: newInterest,
          purchaseTokens: tokens - 1,
          modifierHistory: history
        });

      }
    },

    ...[1, 2, 3, 4, 5].reduce((map, stage) => {
      map[`Stage ${stage} Boost`] = {
        name: `Stage ${stage} Boost`,
        desc: `Increase Stage ${stage} multiplier by +1`,
        apply: async () => {
          const snap = await get(playerRef);
          const data = snap.val();
          const tokens = data.purchaseTokens || 0;
          if (tokens <= 0) return alert("Not enough tokens.");
          const mults = { 1: 2, 2: 3, 3: 4, 4: 20, 5: 500, ...(data.multipliers || {}) };
          mults[stage] = Math.floor(mults[stage] + 1);
          await update(playerRef, { multipliers: mults, purchaseTokens: tokens - 1 });
          alert(`Stage ${stage} multiplier is now ${mults[stage]}Ã—`);

          const history = data.modifierHistory || [];
          history.push(`Increase Stage ${stage} multiplier by +1`);

          await update(playerRef, {
            purchaseTokens: tokens - 1,
            modifierHistory: history
          });

        }
      };
      return map;
    }, {}),

    ...Object.fromEntries([1,2,3,4,5].map(stage => {
      return [`Stage ${stage} Shield`, {
        name: `Stage ${stage} Shield`,
        desc: `Retain 25% of your bet if you fail on Stage ${stage}`,
        apply: async () => {
          const snap = await get(playerRef);
          const data = snap.val();
          const tokens = data.purchaseTokens || 0;

          // â†ªâ€” block if they already own this stageâ€‘shield
          if (data.shields && data.shields[stage]) {
            return alert(`âš ï¸ You already have Stage ${stage} Shield.`);
          }

          if (tokens <= 0) return alert("You don't have enough tokens.");

          const shields = data.shields || {};
          shields[stage] = 25; // percent

          await update(playerRef, {
            shields,
            purchaseTokens: tokens - 1
          });

          alert(`You are now protected on Stage ${stage}. You will recover 25% of your bet if you fail.`);

          const history = data.modifierHistory || [];
          history.push(`Retain 25% of your bet if you fail on Stage ${stage}`);

          await update(playerRef, {
            purchaseTokens: tokens - 1,
            modifierHistory: history
          });

        }
      }];
    })),

  };


  // â”€â”€â”€ Card Upgrade Section â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  // 4) Render the Bet Modifiers (uses betModifiersMap defined elsewhere)
  const betDiv = document.getElementById('betModifiers');
  betDiv.innerHTML = '<div style="width:100%;text-align:center;font-weight:bold;margin-bottom:0.5rem;">Bet Modifiers</div>';
  shownNames.forEach(name => {
    const mod = betModifiersMap[name];
    const box = document.createElement('div');
    box.className = 'shop-item';
    box.innerHTML = `
      <h4>ðŸ› ï¸ ${mod.name}</h4>
      <p>${mod.desc}</p>
    `;
    const btn = document.createElement('button');
    btn.innerText = 'Purchase';
    btn.onclick = async () => {
      if (playerData.purchaseTokens <= 0) return alert("You don't have enough tokens.");
      await mod.apply();
      btn.disabled = true;
      btn.textContent = 'Purchased';
      document.getElementById('playerTokens').textContent = `Tokens: ${playerData.purchaseTokens - 1}`;
    };
    box.appendChild(btn);
    betDiv.appendChild(box);
  });

  // â”€â”€â”€ Card Upgrade Section â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  // Pick one random card instance from their deck
  const fullDeck    = buildPlayerDeck(playerData);
  const upgradeCard = fullDeck[Math.floor(Math.random() * fullDeck.length)];

  // Decide which cardâ€upgrade effects to show
  const allEffects = [
  '+1 bet',
  'Gain 25% of bet',
  'remove_card',
  'Gain 10% of Balance',
  'duplicate_card',
  '+3 Mult',
  '1.25x Mult',
  ];
  const effectsToShow = playerData.offeredEffects 
                      || allEffects.sort(() => Math.random() - 0.5)
                                   .slice(isWinner ? 3 : 2);

  // Render the Card Upgrade shop
  const cardDiv = document.getElementById('cardUpgradeArea');
  cardDiv.innerHTML =
    '<div style="width:100%; text-align:center; font-weight:bold; margin-bottom:0.5rem;">Card Upgrade</div>';


  const upgradeFlex = document.createElement('div');
  upgradeFlex.style.display = 'flex';
  upgradeFlex.style.flexWrap = 'wrap';
  upgradeFlex.style.justifyContent = 'center';
  upgradeFlex.style.gap = '1rem';
  upgradeFlex.style.marginTop = '0.5rem';

  // find any existing upgrade on this card
  const existing = (playerData.cardUpgrades || [])
                   .find(u => u.text === upgradeCard.text)?.effect;

  effectsToShow.forEach(effectText => {
    const box = document.createElement('div');
    box.className = 'shop-item';
    box.style.flex = '1 1 120px';

    // show glow only if the card already has an upgrade
    const cardEl = createCardDisplay(upgradeCard, existing);
    cardEl.style.margin = '0 auto';
    box.appendChild(cardEl);

    // Humanâ€readable description of the offered upgrade
    const desc = document.createElement('p');
    if (effectText === '+1 bet')             desc.textContent = '+1 bet if drawn';
    else if (effectText === 'Gain 25% of bet') desc.textContent = 'Gain 25% of your bet';
    else if (effectText === 'Gain 10% of Balance') desc.textContent = 'Gain 10% of your balance';
    else if (effectText === 'remove_card')   desc.textContent = 'Remove this card from your deck';
    else if (effectText === 'duplicate_card')desc.textContent = 'Duplicate this card into your deck';
    else if (effectText === '+3 Mult')  desc.textContent = '+3 multiplier when drawn';
    else if (effectText === '1.25x Mult') desc.textContent = '1.25x multiplier when drawn';

    box.appendChild(desc);

    // Purchase button
    const btn = document.createElement('button');
    btn.textContent = 'Upgrade';
    if ((playerData.purchaseTokens || 0) <= 0) btn.disabled = true;

    btn.onclick = async () => {
      // 1ï¸âƒ£ Fetch freshest player data
      const snap   = await get(playerRef);
      const latest = snap.val() || {};
      const tokens = latest.purchaseTokens || 0;
      if (tokens <= 0) return alert("You don't have any tokens left!");

      // 2ï¸âƒ£ Map effectâ€codes â†’ human descriptions
      const mapDesc = {
        '+1 bet':          `+1 bet if drawn`,
        'Gain 25% of bet':   `Gain 25% of your bet`,
        'Gain 10% of Balance':   `Gain 10% of your balance`,
        'remove_card':     `Remove this card from your deck`,
        'duplicate_card':  `Duplicate this card into your deck`,
        '+3 Mult':    `+3 multiplier when drawn`,
        '1.25x Mult': `1.25x multiplier when drawn`
      };

      // 3ï¸âƒ£ Prepare history & upgrade arrays
      const history      = latest.modifierHistory || [];
      const cardUpgrades = latest.cardUpgrades   || [];
      const dupCounts    = latest.duplicateCounts || {};

      // 4ï¸âƒ£ Check for an existing upgrade on this card
      const oldIdx = cardUpgrades.findIndex(u => u.text === upgradeCard.text);
      let entryText;

      if (oldIdx !== -1) {
        // Replacing an old effect
        const oldCode = cardUpgrades[oldIdx].effect;
        const oldDesc = mapDesc[oldCode] || oldCode;
        const newDesc = mapDesc[effectText];
        entryText = `${upgradeCard.text}: Replaced with ${newDesc}`;
        cardUpgrades.splice(oldIdx, 1);
      } else {
        // Firstâ€time upgrade
        const newDesc = mapDesc[effectText];
        entryText = `${upgradeCard.text}: ${newDesc}`;
      }

      // 5ï¸âƒ£ Apply the new effect
      if (effectText === 'duplicate_card') {
        // handle stacking duplicates
        const newCount = (dupCounts[upgradeCard.text] || 0) + 1;
        dupCounts[upgradeCard.text] = newCount;
        history.push(`Duplicate ${upgradeCard.text} (x${newCount})`);
      } else {
        // all other cardâ€upgrades go here
        cardUpgrades.push({ text: upgradeCard.text, effect: effectText });
        history.push(entryText);
      }

      // 6ï¸âƒ£ Build update payload
      const updates = {
        purchaseTokens:   tokens - 1,
        modifierHistory:  history,
        duplicateCounts:  dupCounts,
        cardUpgrades
      };

      // 7ï¸âƒ£ Persist and update UI
      await update(playerRef, updates);
      btn.disabled = true;
      btn.textContent = oldIdx === -1 ? 'Upgraded' : 'Replaced';
      document.getElementById('playerTokens')
              .textContent = `Tokens: ${tokens - 1}`;
    };

    box.appendChild(btn);
    upgradeFlex.appendChild(box);
  });

  cardDiv.appendChild(upgradeFlex);
}


// Utility for drawing a random card from the full deck
function getRandomCardFromDeck() {
  const suits = ['â™ ', 'â™¥', 'â™¦', 'â™£'];
  const values = ['2','3','4','5','6','7','8','9','10','J','Q','K','A'];
  const suit = suits[Math.floor(Math.random() * suits.length)];
  const value = values[Math.floor(Math.random() * values.length)];
  const numeric = value === 'A' ? 14 : value === 'K' ? 13 : value === 'Q' ? 12 : value === 'J' ? 11 : parseInt(value);
  return { text: value + suit, suit, value: numeric };
}

function clearCountdown() {
  clearInterval(countdownInterval);
  clearTimeout(countdownTimeout);
  const bar = document.getElementById("timerBar");
  const container = document.getElementById("timerBarContainer");
  bar.style.width = "0%";
  container.style.display = "none";
}

function playSuccessTone() {
  const audioCtx = new (window.AudioContext || window.webkitAudioContext)();

  const melody = [329.63, 369.99, 392.00, 440.00, 659.25, 783.99]; // E F# G A E5 G5
  const notesToPlay = melody.slice(0, Math.min(correctGuessCount, melody.length));
  const duration = 0.18;

  notesToPlay.forEach((freq, i) => {
    const osc = audioCtx.createOscillator();
    osc.frequency.setValueAtTime(freq, audioCtx.currentTime + i * duration);
    osc.type = 'triangle';

    const gainNode = audioCtx.createGain();
    gainNode.gain.setValueAtTime(0.3, audioCtx.currentTime + i * duration);
    gainNode.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + (i + 1) * duration);

    osc.connect(gainNode).connect(audioCtx.destination);
    osc.start(audioCtx.currentTime + i * duration);
    osc.stop(audioCtx.currentTime + (i + 1) * duration);
  });
}

function playFailureTone() {
  const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  // A simple descending 3â€note â€œsadâ€ motif
  const melody = [220, 196, 164.81];  // A3 â†’ G3 â†’ E3
  const duration = 0.3;

  melody.forEach((freq, i) => {
    const osc = audioCtx.createOscillator();
    osc.type = 'triangle';
    osc.frequency.setValueAtTime(freq, audioCtx.currentTime + i * duration);

    const gain = audioCtx.createGain();
    gain.gain.setValueAtTime(0.3, audioCtx.currentTime + i * duration);
    gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + (i + 1) * duration);

    osc.connect(gain).connect(audioCtx.destination);
    osc.start(audioCtx.currentTime + i * duration);
    osc.stop(audioCtx.currentTime + (i + 1) * duration);
  });
}


async function resetAllPlayers(players) {
  for (const id of Object.keys(players)) {
    const pRef   = ref(db, `games/${lobbyCode}/players/${id}`);
    const snap   = await get(pRef);
    const pdata  = snap.val() || {};

    // apply their multiplier (default = 1)
    const mult      = pdata.startBalanceMultiplier || 1;
    const startAmt  = Math.floor(100 * mult);

    await update(pRef, {
      balance:      startAmt,
      betsMade:     0,
      eliminated:   false,
      isRoundWinner: false,
      roundBetBonus: 0
    });
  }

  // sync local copy for this client
  if (players[playerId]) {
    const me  = players[playerId];
    const m   = me.startBalanceMultiplier || 1;
    localPlayer.balance  = Math.floor(100 * m);
    localPlayer.betsMade = 0;
    localPlayer.eliminated = false;
  }
}


async function reshuffleDeck() {
  const fullDeck = [];
  const suits = ['â™ ', 'â™¥', 'â™¦', 'â™£'];
  const values = ['2','3','4','5','6','7','8','9','10','J','Q','K','A'];
  for (const suit of suits) {
    for (const val of values) {
      fullDeck.push({
        text: val + suit,
        suit,
        value: val === 'A' ? 14 : val === 'K' ? 13 : val === 'Q' ? 12 : val === 'J' ? 11 : parseInt(val)
      });
    }
  }
  fullDeck.sort(() => Math.random() - 0.5);
  await set(deckRef, fullDeck);
}

async function grantTokenAndShowShop(winners) {
  const playersSnap = await get(ref(db, `games/${lobbyCode}/players`));
  const players = playersSnap.val();

  // ðŸ§  Generate shared random modifiers for this shop session
  const activeModifierKeys = [
  "Bonus Bets", "Super Multiplier", "Bonus Interest",
  "Stage 1 Boost", "Stage 2 Boost", "Stage 3 Boost", "Stage 4 Boost",
  "Stage 1 Shield", "Stage 2 Shield", "Stage 3 Shield", "Stage 4 Shield", "Stage 5 Shield",
  "All In Bonus","Blue Suits & Boost","Remove Diamonds & Clubs","Snow-baller","Ace & Two","Faceless",
  "Remove 2-4","Starting Balance Boost","Humble Beginnings","Clutch King","Kingpin",
];

const everymodifierkey = [
  "Bonus Bets", "Super Multiplier", "Bonus Interest",
  "Stage 1 Boost", "Stage 2 Boost", "Stage 3 Boost", "Stage 4 Boost", "Stage 5 Boost",
  "Stage 1 Shield", "Stage 2 Shield", "Stage 3 Shield", "Stage 4 Shield", "Stage 5 Shield",
  "All In Bonus","Blue Suits & Boost","Remove Diamonds & Clubs","Snow-baller","Ace & Two","Faceless",
  "Remove 2-4","Starting Balance Boost","Humble Beginnings","Clutch King",
];

  const shuffled = activeModifierKeys.sort(() => Math.random() - 0.5);
  const sharedBetModifiers = shuffled.slice(0, 4); // Change to 4+ if you want more choices

  await update(stateRef, { sharedBetModifiers }); // ðŸ” Save in Firebase so all players use same base


  for (const [id, data] of Object.entries(players)) {
    const isWinner = winners.some(([winnerId]) => winnerId === id);
    const newTokens = (data.purchaseTokens || 0) + 1;

    const upgradeCard = getRandomCardFromDeck();
    const possibleEffects = [
      '+1 bet',
      'Gain 25% of bet',
      'remove_card',
      'Gain 10% of Balance',
      'duplicate_card',
      '+3 Mult',
      '1.25x Mult',
    ];
    const effectsToShow = isWinner ? 3 : 2;
    const randomEffects = [...possibleEffects].sort(() => Math.random() - 0.5).slice(0, effectsToShow);

    await update(ref(db, `games/${lobbyCode}/players/${id}`), {
      purchaseTokens: newTokens,
      showShop: true,
      isRoundWinner: isWinner,
      offeredCard: upgradeCard,
      offeredEffects: randomEffects
    });
  }
}

async function checkRoundCompletion() {
  const playersSnap = await get(ref(db, `games/${lobbyCode}/players`));
  const players = playersSnap.val();
  const activePlayers = Object.values(players).filter(p => !p.eliminated);
  const nonEliminated = activePlayers.filter(p => p.balance > 0);

  const isSoloMode = Object.keys(players).length === 1;
  const isDefaultWin = Object.keys(players).length > 1 && nonEliminated.length === 1;

  const currentStateSnap = await get(stateRef);
  const currentState = currentStateSnap.val();
  const currentMaxBets = currentState?.maxBetsPerPlayer || 10;

  // SOLO MODE
  if (isSoloMode) {
    const soloPlayer = Object.values(players)[0];
    const snap = await get(playerRef);
    const data = snap.val();
    const bonus = data.betModifierBonus || 0;
    const effectiveMax = maxBetsPerPlayer + bonus;

    if (soloPlayer.betsMade < effectiveMax) return;

    const winners = [[playerId, soloPlayer]];
    await update(ref(db, `games/${lobbyCode}/players/${playerId}`), {
      roundsWon: (soloPlayer.roundsWon || 0) + 1
    });

    await resetAllPlayers(players);
    await reshuffleDeck();
    await grantTokenAndShowShop(winners);
    const currentStateSnap2 = await get(stateRef);
    const stateObj = currentStateSnap2.val() || {};
    await update(stateRef, { status: stateObj.status + ' ' });
    await set(stateRef, {
      gameStarted: true,
      currentPlayer: playerId,
      currentStage: 0,
      drawnCards: [],
      status: `Waiting for ${soloPlayer.name} to start their turn.`,
      maxBetsPerPlayer: currentMaxBets
    });

    return;
  }

  // DEFAULT WIN
  if (isDefaultWin) {
    const lastPlayerId = Object.entries(players).find(([_, p]) => p.balance > 0 && !p.eliminated)[0];
    const lastPlayer = players[lastPlayerId];
    const winners = [[lastPlayerId, lastPlayer]];

    await update(ref(db, `games/${lobbyCode}/players/${lastPlayerId}`), {
      roundsWon: (lastPlayer.roundsWon || 0) + 1
    });

    alert(`${lastPlayer.name} has won the round by default!`);

    await resetAllPlayers(players);
    await reshuffleDeck();

    // ðŸ§  Set game state *before* granting tokens/shop
    await set(stateRef, {
      gameStarted: true,
      currentPlayer: lastPlayerId,
      currentStage: 0,
      drawnCards: [],
      status: `Waiting for ${lastPlayer.name} to start their turn.`,
      maxBetsPerPlayer: currentMaxBets
    });

    // ðŸª™ This now triggers correctly when state.currentStage is already 0
    await grantTokenAndShowShop(winners);
    const currentStateSnap2 = await get(stateRef);
    const stateObj = currentStateSnap2.val() || {};
    await update(stateRef, { status: stateObj.status + ' ' });
    return;
  }


// CONTINUE IF ANYONE HAS BETS LEFT
const allDone = activePlayers.every(p => {
  const permBonus = p.betModifierBonus || 0;
  const roundBonus = p.roundBetBonus || 0;
  const effectiveMax = maxBetsPerPlayer + permBonus + roundBonus;
  return p.betsMade >= effectiveMax;
});
if (!allDone) return advanceToNextPlayer();

  // NORMAL WIN SCENARIO
  const maxBalance = Math.max(...activePlayers.map(p => p.balance));
  const winners = Object.entries(players).filter(([_, p]) => p.balance === maxBalance);

  for (const [id, p] of winners) {
    await update(ref(db, `games/${lobbyCode}/players/${id}`), {
      roundsWon: (p.roundsWon || 0) + 1
    });
  }

  await resetAllPlayers(players);
  await reshuffleDeck();
  await grantTokenAndShowShop(winners);
  const currentStateSnap2 = await get(stateRef);
  const stateObj = currentStateSnap2.val() || {};
  await update(stateRef, { status: stateObj.status + ' ' });

  const firstPlayerId = Object.keys(players)[0];
  await set(stateRef, {
    gameStarted: true,
    currentPlayer: firstPlayerId,
    currentStage: 0,
    drawnCards: [],
    status: `Waiting for ${players[firstPlayerId].name} to start their turn.`,
    maxBetsPerPlayer: currentMaxBets
  });
}

async function showDeck() {
  // 1) fetch your player data
  const snap = await get(playerRef);
  const playerData = snap.val() || {};

  // 2) rebuild your actual deck and get your upgrades
  let deck     = buildPlayerDeck(playerData);  const dupCounts  = playerData.duplicateCounts || {};
  for (const [text, count] of Object.entries(dupCounts)) {
    const template = deck.find(c => c.text === text);
    if (!template) continue;
    // push N extra visual copies
    for (let i = 0; i < count; i++) {
      deck.push({ ...template });
    }
  }
    // â”€â”€â”€ new: sort by suit then value â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  const suitOrder = ['â™¥','â™¦','â™ ','â™£','â˜¾','â˜…'];
  deck.sort((a, b) => {
    const s = suitOrder.indexOf(a.suit) - suitOrder.indexOf(b.suit);
    return s !== 0 ? s : a.value - b.value;
  });


  const upgrades = playerData.cardUpgrades || [];

  // 3) render into the modal
  const container = document.getElementById('deckContent');
  container.innerHTML = '';  // clear previous

  // create a flex grid
  const grid = document.createElement('div');
  grid.style.display      = 'flex';
  grid.style.flexWrap     = 'wrap';
  grid.style.gap          = '0.5rem';
  grid.style.justifyContent = 'flex-start';

  deck.forEach(card => {
    // find if this exact card has an upgrade
    const match = upgrades.find(u => u.text === card.text);

    // create the card element (this applies color + glow)
    const cardEl = createCardDisplay(card, match?.effect);

    // optionally add a tooltip/title if they have an upgrade
    if (match) {
      cardEl.title = match.effect.replace(/_/g, ' ');
    }

    grid.appendChild(cardEl);
  });

  container.appendChild(grid);

  // 4) show the modal
  document.getElementById('deckModal').classList.remove('hidden');
}


</script>

</body>
</html>
